# 错误处理系统使用指南

## 概述

本项目已集成完整的错误边界处理系统,包括:
- ✅ 全局错误捕获
- ✅ Vue 组件错误边界
- ✅ API 请求错误统一处理
- ✅ 错误日志记录
- ✅ 用户友好的错误提示
- ✅ 开发环境详细错误信息

## 核心功能

### 1. 错误类型分类

```typescript
import { ErrorType, AppError } from '@/utils/errorHandler'

// 网络错误
const networkError = new AppError('网络连接失败', ErrorType.NETWORK)

// 业务错误
const businessError = new AppError('数据不存在', ErrorType.BUSINESS, 404)

// 权限错误
const permissionError = new AppError('无权访问', ErrorType.PERMISSION, 403)

// 验证错误
const validationError = new AppError('表单验证失败', ErrorType.VALIDATION)

// 运行时错误
const runtimeError = new AppError('应用异常', ErrorType.RUNTIME)
```

### 2. 组件级错误边界

在组件中使用 ErrorBoundary:

```vue
<template>
  <ErrorBoundary :show-details="true">
    <YourComponent />
  </ErrorBoundary>
</template>

<script setup>
import ErrorBoundary from '@/components/ErrorBoundary.vue'
</script>
```

### 3. Composable Hooks

#### useRequest - 请求状态管理

```typescript
import { useRequest } from '@/composables/useErrorHandler'
import { getUserList } from '@/api/user'

const { loading, data, error, execute } = useRequest(
  getUserList,
  {
    immediate: true, // 立即执行
    showErrorMessage: true, // 显示错误消息
    successMessage: '加载成功',
    onSuccess: (data) => {
      console.log('请求成功', data)
    },
    onError: (error) => {
      console.error('请求失败', error)
    }
  }
)

// 手动执行
await execute({ page: 1, pageSize: 10 })
```

#### useFormSubmit - 表单提交

```typescript
import { useFormSubmit } from '@/composables/useErrorHandler'

const formRef = ref()
const { submitting, submit } = useFormSubmit(
  async (formData) => {
    return await createUser(formData)
  },
  {
    validate: async () => {
      return await formRef.value.validate()
    },
    onSuccess: (data) => {
      ElMessage.success('创建成功')
      router.push('/users')
    },
    successMessage: '提交成功'
  }
)

// 提交表单
await submit(formData)
```

#### useList - 列表加载

```typescript
import { useList } from '@/composables/useErrorHandler'

const {
  loading,
  list,
  total,
  page,
  pageSize,
  fetch,
  refresh,
  reset,
  handlePageChange,
  handleSizeChange
} = useList(
  getResultList,
  {
    immediate: true,
    pagination: { page: 1, pageSize: 20 }
  }
)

// 刷新列表
refresh()

// 重置并加载
reset()

// 分页变化
handlePageChange(2)
handleSizeChange(50)
```

#### useDelete - 删除确认

```typescript
import { useDelete } from '@/composables/useErrorHandler'

const { deleting, confirmDelete } = useDelete(
  deleteResult,
  {
    confirmMessage: '确定要删除这个成果吗?',
    successMessage: '删除成功',
    onSuccess: () => {
      refresh() // 刷新列表
    }
  }
)

// 删除操作
const handleDelete = async (id: string) => {
  const success = await confirmDelete(id)
  if (success) {
    console.log('删除成功')
  }
}
```

#### useAsyncAction - 异步操作

```typescript
import { useAsyncAction } from '@/composables/useErrorHandler'

const { executing, execute } = useAsyncAction(
  publishResult,
  {
    successMessage: '发布成功',
    onSuccess: () => {
      refresh()
    }
  }
)

// 执行操作
await execute(resultId)
```

### 4. 辅助函数

#### tryCatch - 安全的异步操作

```typescript
import { tryCatch } from '@/utils/errorHandler'

const [data, error] = await tryCatch(
  async () => {
    return await fetchData()
  },
  {
    showError: true,
    errorMessage: '获取数据失败',
    defaultValue: []
  }
)

if (error) {
  console.error('操作失败', error)
} else {
  console.log('操作成功', data)
}
```

#### asyncErrorHandler - 包装异步函数

```typescript
import { asyncErrorHandler } from '@/utils/errorHandler'

const safeFunction = asyncErrorHandler(
  async (id: string) => {
    return await dangerousOperation(id)
  },
  {
    showError: true,
    errorMessage: '操作失败',
    onError: (error) => {
      console.error(error)
    }
  }
)

// 使用
await safeFunction('123')
```

### 5. 错误日志

```typescript
import { errorLogger } from '@/utils/errorHandler'

// 查看所有错误日志
const logs = errorLogger.getLogs()

// 清空日志
errorLogger.clearLogs()

// 手动记录错误
errorLogger.log(new AppError('自定义错误', ErrorType.BUSINESS))
```

## 实际应用示例

### 示例 1: 列表页面

```vue
<template>
  <div>
    <el-table :data="list" v-loading="loading">
      <!-- 表格列 -->
    </el-table>
    
    <el-pagination
      :current-page="page"
      :page-size="pageSize"
      :total="total"
      @current-change="handlePageChange"
      @size-change="handleSizeChange"
    />
  </div>
</template>

<script setup lang="ts">
import { useList, useDelete } from '@/composables/useErrorHandler'
import { getResultList, deleteResult } from '@/api/result'

const {
  loading,
  list,
  total,
  page,
  pageSize,
  refresh,
  handlePageChange,
  handleSizeChange
} = useList(getResultList, { immediate: true })

const { confirmDelete } = useDelete(deleteResult, {
  onSuccess: refresh
})

const handleDelete = (id: string) => confirmDelete(id)
</script>
```

### 示例 2: 表单提交

```vue
<template>
  <el-form ref="formRef" :model="form" :rules="rules">
    <el-form-item label="标题" prop="title">
      <el-input v-model="form.title" />
    </el-form-item>
    
    <el-button 
      type="primary" 
      :loading="submitting"
      @click="handleSubmit"
    >
      提交
    </el-button>
  </el-form>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue'
import { useFormSubmit } from '@/composables/useErrorHandler'
import { createResult } from '@/api/result'

const formRef = ref()
const form = reactive({ title: '' })
const rules = { 
  title: [{ required: true, message: '请输入标题' }] 
}

const { submitting, submit } = useFormSubmit(
  createResult,
  {
    validate: () => formRef.value.validate(),
    successMessage: '创建成功',
    onSuccess: () => {
      router.push('/results')
    }
  }
)

const handleSubmit = () => submit(form)
</script>
```

### 示例 3: 异步操作

```vue
<script setup lang="ts">
import { useAsyncAction } from '@/composables/useErrorHandler'
import { publishResult, revokeResult } from '@/api/result'

const { executing: publishing, execute: publish } = useAsyncAction(
  publishResult,
  {
    successMessage: '发布成功',
    onSuccess: () => refresh()
  }
)

const { executing: revoking, execute: revoke } = useAsyncAction(
  revokeResult,
  {
    successMessage: '撤销成功',
    onSuccess: () => refresh()
  }
)

const handlePublish = (id: string) => publish(id)
const handleRevoke = (id: string) => revoke(id)
</script>
```

## 最佳实践

### ✅ 推荐做法

1. **使用 Composable Hooks**
```typescript
// ✅ 好的做法
const { loading, execute } = useRequest(fetchData)
```

2. **统一错误处理**
```typescript
// ✅ 让系统自动处理错误
const { data } = await execute()
```

3. **使用 ErrorBoundary**
```vue
<!-- ✅ 在关键组件外包裹 ErrorBoundary -->
<ErrorBoundary>
  <ComplexComponent />
</ErrorBoundary>
```

### ❌ 避免做法

1. **不要手动 try-catch 每个请求**
```typescript
// ❌ 不推荐
try {
  const res = await fetchData()
} catch (error) {
  ElMessage.error(error.message)
}

// ✅ 推荐
const { execute } = useRequest(fetchData, { showErrorMessage: true })
await execute()
```

2. **不要吞掉错误**
```typescript
// ❌ 不推荐
try {
  await dangerousOperation()
} catch (error) {
  // 什么都不做
}

// ✅ 推荐
const [, error] = await tryCatch(dangerousOperation)
if (error) {
  // 处理错误或让系统自动处理
}
```

## 配置选项

在 `.env` 文件中配置:

```env
# 开发环境显示详细错误
VITE_SHOW_ERROR_DETAILS=true

# 错误日志上报地址
VITE_ERROR_REPORT_URL=https://your-error-tracking-service.com
```

## 监控集成

可以集成第三方错误监控服务 (Sentry, LogRocket 等):

```typescript
// src/utils/errorHandler.ts
private reportToServer(errorLog: ErrorLog) {
  // Sentry 集成示例
  if (window.Sentry) {
    window.Sentry.captureException(new Error(errorLog.message), {
      extra: errorLog
    })
  }
  
  // 或自定义上报
  fetch(import.meta.env.VITE_ERROR_REPORT_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(errorLog)
  }).catch(() => {})
}
```

## 总结

错误处理系统已全面集成到项目中,提供了:
- 🛡️ 全局错误防护
- 📊 错误日志追踪
- 🎯 精准的错误类型分类
- 💡 用户友好的错误提示
- 🔧 开发环境详细调试信息
- 🚀 便捷的 Composable Hooks

推荐在所有新代码中使用提供的 Hooks 和工具函数,以保持错误处理的一致性和可维护性。
